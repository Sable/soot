package soot.defaultInterfaceMethods;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.google.common.collect.Sets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.junit.Assert;
import org.junit.Test;
import soot.Body;
import soot.FastHierarchy;
import soot.MethodOrMethodContext;
<<<<<<< HEAD
import soot.PhaseOptions;
import soot.RefType;
import soot.SootClass;
=======
>>>>>>> Merge and apply some fixes to Pavan's test suite
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Unit;
import soot.UnitPatchingChain;
import soot.jimple.Stmt;
import soot.jimple.toolkits.callgraph.Edge;
import soot.jimple.toolkits.callgraph.ReachableMethods;
import soot.jimple.toolkits.callgraph.VirtualCalls;
import soot.testing.framework.AbstractTestingFramework;

/** */
public class DefaultInterfaceTest extends AbstractTestingFramework {
	@Override
	protected void setupSoot() {
		super.setupSoot();
		PhaseOptions.v().setPhaseOption("cg.cha", "on");
	}


  @Test
  public void simpleDefaultInterfaceTest() {

    String testClass = "soot.defaultInterfaceMethods.SimpleDefaultInterface";
    String defaultClass = "soot.defaultInterfaceMethods.Default";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.Default");

    SootMethod defaultMethod =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.Default: void target()>");
    Body body = target.retrieveActiveBody();
    SootMethod targetMethod = resolveMethodRefInBody(body.getUnits(), "void target()");
    SootMethod resolvedMethod =
        VirtualCalls.v().resolveNonSpecial(Scene.v().getRefType(testClass), defaultMethod, false);
    SootMethod concreteImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), defaultMethod);
    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), defaultMethod);

    boolean edgePresent = checkInEdges(defaultMethod, target);
    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();
    /* Arguments for assert function */

    assertEquals(defaultMethod, resolvedMethod);
    assertEquals(defaultMethod, targetMethod);
    assertEquals(defaultMethod.getName(), "target");
    assertNotNull(defaultMethod);
    assertTrue(reachableMethods.contains(defaultMethod));
    assertTrue(edgePresent);
    assertEquals(defaultMethod, concreteImpl);
    assertTrue(
        abstractImpl.contains(
            Scene.v().getMethod("<soot.defaultInterfaceMethods.Default: void target()>")));
  }

  @Test
<<<<<<< HEAD
  public void interfaceWithSameSignatureTest() {
	  String testClass = "soot.defaultInterfaceMethods.InterfaceSameSignature";
	  String interfaceReadClass = "soot.defaultInterfaceMethods.Read";
	  String interfaceWriteClass = "soot.defaultInterfaceMethods.Write";

	  final SootMethod target =
			  prepareTarget(
					  methodSigFromComponents(testClass, "void", "main"),
					  testClass,
					  "soot.defaultInterfaceMethods.Read", "soot.defaultInterfaceMethods.Write");

	  SootMethod mainPrintMethod = Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void print()>");
	  SootMethod readInterfacePrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.Read: void print()>");
	  SootMethod writeInterfacePrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.Write: void print()>");
	  SootMethod defaultRead = Scene.v().getMethod("<soot.defaultInterfaceMethods.Read: void read()>");
	  SootMethod defaultWrite = Scene.v().getMethod("<soot.defaultInterfaceMethods.Write: void write()>");
	  
	  Body mainBody = target.retrieveActiveBody();
	  Body mainPrintBody = mainPrintMethod.retrieveActiveBody();
	  
	  SootMethod refMainMethod = getSootMethodRef(mainBody.getUnits(), "void print()");
	  SootMethod refWritePrintMethod = getSootMethodRef(mainPrintBody.getUnits(), "soot.defaultInterfaceMethods.Write: void print()");
	  SootMethod refReadPrintMethod = getSootMethodRef(mainPrintBody.getUnits(), "soot.defaultInterfaceMethods.Read: void print()");
	  SootMethod refDefaultRead = getSootMethodRef(mainBody.getUnits(), "void read()");
	  SootMethod refDefaultWrite = getSootMethodRef(mainBody.getUnits(), "void write()");
	  
	  SootMethod resolvedMainMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), mainPrintMethod, false);
	  SootMethod resolvedWritePrintMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), writeInterfacePrint, false);
	  SootMethod resolvedReadPrintMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), readInterfacePrint, false);
	  SootMethod resolvedDefaultReadMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), defaultRead, false);
	  SootMethod resolvedDefaultWriteMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), defaultWrite, false);
	  
	  SootMethod concreteImplMainPrint = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), mainPrintMethod);
	  SootMethod concreteImplReadPrint = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), refReadPrintMethod);
	  SootMethod concreteImplDefaultRead = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), refDefaultRead);
	  SootMethod concreteImplDefaultWrite = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), refDefaultWrite);
	  
	  Set<SootMethod> abstractImplDefaultRead = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(interfaceReadClass), refDefaultRead); 
	  Set<SootMethod> abstractImplDefaultWrite = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(interfaceWriteClass), refDefaultWrite); 
	  Set<SootMethod> abstractImplReadDefaultPrint = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(interfaceReadClass), refReadPrintMethod);
	  Set<SootMethod> abstractImplWriteDefaultPrint = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(interfaceWriteClass), refWritePrintMethod);  
	  
	  
	  final CallGraph cg = Scene.v().getCallGraph();
	  
	  /* Edges should be present */
	  boolean edgeMainPrintToReadPrint = checkInEdges(cg, readInterfacePrint, mainPrintMethod);
	  boolean edgeMainPrintToWritePrint = checkInEdges(cg, writeInterfacePrint, mainPrintMethod);
	  boolean edgeMainMethodToPrint = checkInEdges(cg, mainPrintMethod, target);
	  
	  /* Edges should not be present */
	  boolean edgeMainMethodToReadPrint = checkInEdges(cg, readInterfacePrint, target);
	  boolean edgeMainMethodToWritePrint = checkInEdges(cg, writeInterfacePrint, target);
	  
	  /* Edges should be present */
	  boolean edgeMainMethodToReadMethod = checkInEdges(cg, defaultRead, target);
	  boolean edgeMainMethodToWriteMethod = checkInEdges(cg, defaultWrite, target);

	  final ReachableMethods reachableMethods = Scene.v().getReachableMethods();
	  
	  /* Arguments for assert function */
	  Map<SootMethod, String> targetMethods = new HashMap<SootMethod, String>() {{
		  put(mainPrintMethod, "print");
		  put(readInterfacePrint, "print");
		  put(writeInterfacePrint, "print");
		  put(defaultRead, "read");
		  put(defaultWrite, "write");
	  }};
	  
	  Map<SootMethod, SootMethod> resolvedMethods = new HashMap<SootMethod, SootMethod>() {{
		  put(mainPrintMethod, resolvedMainMethod);
		  put(mainPrintMethod, resolvedWritePrintMethod);
		  put(mainPrintMethod, resolvedReadPrintMethod);
		  put(defaultRead, resolvedDefaultReadMethod);
		  put(defaultWrite, resolvedDefaultWriteMethod);		  
	  }};
	  
	  Map<SootMethod, SootMethod> methodRef = new HashMap<SootMethod, SootMethod>() {{
		  put(mainPrintMethod, refMainMethod);
		  put(writeInterfacePrint, refWritePrintMethod);
		  put(readInterfacePrint, refReadPrintMethod);
		  put(defaultRead, refDefaultRead);
		  put(defaultWrite, refDefaultWrite);		  
	  }};
	  
	  Map<SootMethod, SootMethod> concreteImpl = new HashMap<SootMethod, SootMethod>() {{
		  put(mainPrintMethod, concreteImplMainPrint);
		  put(writeInterfacePrint, concreteImplWritePrint);
		  put(readInterfacePrint, concreteImplReadPrint);
		  put(defaultRead, concreteImplDefaultRead);
		  put(defaultWrite, concreteImplDefaultWrite);		  
	  }};
	  
	  ArrayList<Boolean> edgePresent = new ArrayList<Boolean>() {{
		  add(edgeMainPrintToReadPrint);
		  add(edgeMainPrintToWritePrint);
		  add(edgeMainMethodToPrint);		  
	  }};
	  
	  ArrayList<Boolean> edgeNotPresent = new ArrayList<Boolean>() {{
		  add(edgeMainMethodToReadPrint);
		  add(edgeMainMethodToWritePrint);
		  add(edgeMainMethodToReadMethod);	
		  add(edgeMainMethodToWriteMethod);
	  }};
	  
	  assertInterfaceWithSameSignature(targetMethods, reachableMethods, resolvedMethods, edgePresent, edgeNotPresent, methodRef, concreteImpl, abstractImplDefaultRead, abstractImplDefaultWrite, abstractImplReadDefaultPrint, abstractImplWriteDefaultPrint);
=======
  public void interfaceSameSignatureTest() {
    String testClassSig = "soot.defaultInterfaceMethods.InterfaceSameSignature";
    String interfaceReadSig = "soot.defaultInterfaceMethods.Read";
    String interfaceWriteSig = "soot.defaultInterfaceMethods.Write";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClassSig, "void", "main"),
            testClassSig,
            "soot.defaultInterfaceMethods.Read",
            "soot.defaultInterfaceMethods.Write");

    SootClass testClass = Scene.v().getSootClass(testClassSig);
    SootClass interfaceRead = Scene.v().getSootClass(interfaceReadSig);
    SootClass interfaceWrite = Scene.v().getSootClass(interfaceWriteSig);

    SootMethod mainPrintMethod =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void print()>");
    SootMethod readInterfacePrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.Read: void print()>");
    SootMethod writeInterfacePrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.Write: void print()>");
    SootMethod readInterfaceRead =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.Read: void read()>");
    SootMethod writeInterfaceWrite =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.Write: void write()>");

    Body mainBody = target.retrieveActiveBody();
    Body mainPrintBody = mainPrintMethod.retrieveActiveBody();

    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");
    SootMethod refWritePrintMethod =
        resolveMethodRefInBody(
            mainPrintBody.getUnits(), "soot.defaultInterfaceMethods.Write: void print()");
    SootMethod refReadPrintMethod =
        resolveMethodRefInBody(
            mainPrintBody.getUnits(), "soot.defaultInterfaceMethods.Read: void print()");
    SootMethod refDefaultRead = resolveMethodRefInBody(mainBody.getUnits(), "void read()");
    SootMethod refDefaultWrite = resolveMethodRefInBody(mainBody.getUnits(), "void write()");

    SootMethod resolvedMainMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClassSig), mainPrintMethod, false);
    SootMethod resolvedWritePrintMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClassSig), writeInterfacePrint, false);
    SootMethod resolvedReadPrintMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClassSig), readInterfacePrint, false);
    SootMethod resolvedDefaultReadMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClassSig), readInterfaceRead, false);
    SootMethod resolvedDefaultWriteMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClassSig), writeInterfaceWrite, false);

    FastHierarchy fh = Scene.v().getFastHierarchy();
    SootMethod concreteImplMainPrint = fh.resolveConcreteDispatch(testClass, mainPrintMethod);
    SootMethod concreteImplWritePrint = fh.resolveConcreteDispatch(testClass, refWritePrintMethod);
    SootMethod concreteImplReadPrint = fh.resolveConcreteDispatch(testClass, refReadPrintMethod);
    SootMethod concreteImplDefaultRead = fh.resolveConcreteDispatch(testClass, refDefaultRead);
    SootMethod concreteImplDefaultWrite = fh.resolveConcreteDispatch(testClass, refDefaultWrite);

    assertEquals(
        Sets.newHashSet(readInterfaceRead),
        fh.resolveAbstractDispatch(interfaceRead, refDefaultRead));
    assertEquals(
        Sets.newHashSet(writeInterfaceWrite),
        fh.resolveAbstractDispatch(interfaceWrite, refDefaultWrite));
    assertEquals(
        Sets.newHashSet(mainPrintMethod),
        fh.resolveAbstractDispatch(interfaceRead, refReadPrintMethod));
    assertEquals(
        Sets.newHashSet(mainPrintMethod),
        fh.resolveAbstractDispatch(interfaceWrite, refWritePrintMethod));

    /* Edges should be present */
    boolean edgeMainPrintToReadPrint = checkInEdges(readInterfacePrint, mainPrintMethod);
    boolean edgeMainPrintToWritePrint = checkInEdges(writeInterfacePrint, mainPrintMethod);
    boolean edgeMainMethodToPrint = checkInEdges(mainPrintMethod, target);
    boolean edgeMainMethodToReadMethod = checkInEdges(readInterfaceRead, target);
    boolean edgeMainMethodToWriteMethod = checkInEdges(writeInterfaceWrite, target);

    /* Edges should not be present */
    boolean edgeMainMethodToReadPrint = checkInEdges(readInterfacePrint, target);
    boolean edgeMainMethodToWritePrint = checkInEdges(writeInterfacePrint, target);

    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    /* Arguments for assert function */
    Map<SootMethod, String> targetMethods =
        new HashMap<SootMethod, String>() {
          {
            put(mainPrintMethod, "print");
            put(readInterfacePrint, "print");
            put(writeInterfacePrint, "print");
            put(readInterfaceRead, "read");
            put(writeInterfaceWrite, "write");
          }
        };

    Map<SootMethod, SootMethod> resolvedMethods =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(mainPrintMethod, resolvedMainMethod);
            put(mainPrintMethod, resolvedWritePrintMethod);
            put(mainPrintMethod, resolvedReadPrintMethod);
            put(readInterfaceRead, resolvedDefaultReadMethod);
            put(writeInterfaceWrite, resolvedDefaultWriteMethod);
          }
        };

    Map<SootMethod, SootMethod> methodRef =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(mainPrintMethod, refMainMethod);
            put(writeInterfacePrint, refWritePrintMethod);
            put(readInterfacePrint, refReadPrintMethod);
            put(readInterfaceRead, refDefaultRead);
            put(writeInterfaceWrite, refDefaultWrite);
          }
        };

    Map<SootMethod, SootMethod> concreteImpl =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(mainPrintMethod, concreteImplMainPrint);
            put(mainPrintMethod, concreteImplWritePrint);
            put(mainPrintMethod, concreteImplReadPrint);
            put(readInterfaceRead, concreteImplDefaultRead);
            put(writeInterfaceWrite, concreteImplDefaultWrite);
          }
        };

    ArrayList<Boolean> edgePresent =
        new ArrayList<Boolean>() {
          {
            add(edgeMainPrintToReadPrint);
            add(edgeMainPrintToWritePrint);
            add(edgeMainMethodToPrint);
            add(edgeMainMethodToReadMethod);
            add(edgeMainMethodToWriteMethod);
          }
        };

    ArrayList<Boolean> edgeNotPresent =
        new ArrayList<Boolean>() {
          {
            add(edgeMainMethodToReadPrint);
            add(edgeMainMethodToWritePrint);
          }
        };

    for (Map.Entry<SootMethod, String> targetMethod : targetMethods.entrySet()) {
      assertNotNull(targetMethod.getKey());
    }
    for (Map.Entry<SootMethod, SootMethod> virtualResolvedMethod : resolvedMethods.entrySet()) {
      assertEquals(virtualResolvedMethod.getKey(), virtualResolvedMethod.getValue());
    }
    for (Map.Entry<SootMethod, SootMethod> methodRef1 : methodRef.entrySet()) {
      assertEquals(methodRef1.getKey(), methodRef1.getValue());
    }
    for (Map.Entry<SootMethod, String> targetMethod : targetMethods.entrySet()) {
      assertEquals(targetMethod.getKey().getName(), targetMethod.getValue());
    }
    for (Map.Entry<SootMethod, String> targetMethod : targetMethods.entrySet()) {
      assertTrue(reachableMethods.contains(targetMethod.getKey()));
    }
    for (boolean isPresent : edgePresent) {
      assertTrue(isPresent);
    }
    for (boolean notPresent : edgeNotPresent) {
      assertFalse(notPresent);
    }
    for (Map.Entry<SootMethod, SootMethod> concreteImpl1 : concreteImpl.entrySet()) {
      assertEquals(concreteImpl1.getKey(), concreteImpl1.getValue());
    }
>>>>>>> Merge and apply some fixes to Pavan's test suite
  }

  @Test
  public void classInterfaceWithSameSignatureTest() {
    String testClass = "soot.defaultInterfaceMethods.ClassInterfaceSameSignature";
    String defaultClass = "soot.defaultInterfaceMethods.HelloWorld";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.HelloWorld");

    SootMethod mainPrintMethod =
        Scene.v()
            .getMethod("<soot.defaultInterfaceMethods.ClassInterfaceSameSignature: void print()>");
    SootMethod defaultPrintMethod =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.HelloWorld: void print()>");

    Body mainBody = target.retrieveActiveBody();
    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");
    SootMethod resolvedMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClass), defaultPrintMethod, false);
    SootMethod concreteImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), defaultPrintMethod);
    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), defaultPrintMethod);
    boolean edgeMainMethodToMainPrint = checkInEdges(mainPrintMethod, target);
    boolean edgeMainPrintToDefaultPrint = checkInEdges(defaultPrintMethod, target);
    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    Map<SootMethod, String> targetMethods =
        new HashMap<SootMethod, String>() {
          {
            put(mainPrintMethod, "print");
            put(defaultPrintMethod, "print");
          }
        };

    ArrayList<Boolean> edgePresent =
        new ArrayList<Boolean>() {
          {
            add(edgeMainMethodToMainPrint);
          }
        };

    for (Map.Entry<SootMethod, String> targetMethod : targetMethods.entrySet()) {
      assertNotNull(targetMethod.getKey());
    }
    assertEquals(mainPrintMethod, resolvedMethod);
    assertEquals(mainPrintMethod, refMainMethod);
    for (Map.Entry<SootMethod, String> targetMethod : targetMethods.entrySet()) {
      assertEquals(targetMethod.getKey().getName(), targetMethod.getValue());
    }

    assertTrue(reachableMethods.contains(mainPrintMethod));

    for (boolean isPresent : edgePresent) {
      assertTrue(isPresent);
    }
    assertEquals(mainPrintMethod, concreteImpl);
    assertTrue(
        abstractImpl.contains(
            Scene.v()
                .getMethod(
                    "<soot.defaultInterfaceMethods.ClassInterfaceSameSignature: void print()>")));
  }

  @Test
  public void superClassInterfaceWithSameSignatureTest() {
<<<<<<< HEAD
	  String testClass = "soot.defaultInterfaceMethods.SuperClassInterfaceSameSignature";
	  String defaultClass = "soot.defaultInterfaceMethods.PrintInterface";
	  String defaultSuperClass = "soot.defaultInterfaceMethods.DefaultPrint";

	  final SootMethod target =
			  prepareTarget(
					  methodSigFromComponents(testClass, "void", "main"),
					  testClass,
					  "soot.defaultInterfaceMethods.PrintInterface", "soot.defaultInterfaceMethods.SuperClassImplementsInterface");

	  SootMethod defaultSuperMainMethod = Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void main()>");
	  SootMethod mainMethod = Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>");
	  SootMethod defaultMethod = Scene.v().getMethod("<soot.defaultInterfaceMethods.PrintInterface: void print()>");
	  SootMethod defaultSuperClassMethod = Scene.v().getMethod("<soot.defaultInterfaceMethods.DefaultPrint: void print()>");
	  
	  Body mainBody = target.retrieveActiveBody();
	  SootMethod refMainMethod = getSootMethodRef(mainBody.getUnits(), "void print()");
	  
	  SootMethod resolvedMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), defaultMethod, false);
	  SootMethod resolvedSuperClassDefaultMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), defaultSuperClassMethod, false);
	  
	  SootMethod concreteImpl = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), defaultMethod);
	  
	  Set<SootMethod> abstractImpl = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), defaultMethod);
	  Set<SootMethod> abstractImplSuperClass = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultSuperClass), defaultSuperClassMethod);

	  final CallGraph cg = Scene.v().getCallGraph();
	  
	  boolean edgeMainToSuperClassPrint = checkInEdges(cg, mainMethod, target);
	  boolean edgeMainToDefaultPrint = checkInEdges(cg, defaultMethod, target);
	  boolean edgeMainToSuperDefaultPrint = checkInEdges(cg, defaultSuperClassMethod, target);
	  boolean edgeSuperMainToSuperPrint = checkInEdges(cg, defaultSuperClassMethod, defaultSuperMainMethod);

	  final ReachableMethods reachableMethods = Scene.v().getReachableMethods();
	  
	  List<SootMethod> targetMethods = new ArrayList<SootMethod>() {{
		  add(mainMethod);
		  add(defaultMethod);
		  add(defaultSuperClassMethod);
	  }};
	  
	  ArrayList<Boolean> edgeNotPresent = new ArrayList<Boolean>() {{
		  add(edgeMainToDefaultPrint);
		  add(edgeMainToSuperDefaultPrint);
		  add(edgeSuperMainToSuperPrint);
	  }};
	  
	  Map<SootMethod, SootMethod> resolvedMethods = new HashMap<SootMethod, SootMethod>() {{
		  put(mainMethod, resolvedMethod);
		  put(resolvedSuperClassDefaultMethod, resolvedMethod);		  		  
	  }};
	  
	  assertSuperClassInterfaceWithSameSignature(targetMethods, resolvedMethods, refMainMethod, reachableMethods, edgeMainToSuperClassPrint, edgeNotPresent, concreteImpl, abstractImpl, abstractImplSuperClass);  
  }  

  @Test
  public void derivedInterfacesTest() {
	  String testClass = "soot.defaultInterfaceMethods.DerivedInterfaces";
	  String defaultInterfaceOne = "soot.defaultInterfaceMethods.InterfaceTestOne";
	  String defaultInterfaceTwo = "soot.defaultInterfaceMethods.InterfaceTestTwo";
	  
	  final SootMethod target =
			  prepareTarget(
					  methodSigFromComponents(testClass, "void", "main"),
					  testClass,
					  "soot.defaultInterfaceMethods.InterfaceTestOne", "soot.defaultInterfaceMethods.InterfaceTestTwo");	  
	  
	  SootMethod interfaceOnePrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTestOne: void print()>");
	  SootMethod interfaceTwoPrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTestTwo: void print()>");
	  
	  Body mainBody = target.retrieveActiveBody();
	  SootMethod refMainMethod = getSootMethodRef(mainBody.getUnits(), "void print()");
	  
	  SootMethod interfaceOneResolvedMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), interfaceOnePrint, false);
	  SootMethod interfaceTwoResolvedMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), interfaceTwoPrint, false);
	  
	  SootMethod concreteImplInterfaceOne = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceOnePrint);
	  SootMethod concreteImplInterfaceTwo = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceTwoPrint);
	  
	  Set<SootMethod> abstractImplInterfaceOne = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultInterfaceOne), interfaceOnePrint);
	  Set<SootMethod> abstractImplInterfaceTwo = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultInterfaceTwo), interfaceTwoPrint);
	  
	  final CallGraph cg = Scene.v().getCallGraph();
	  
	  boolean edgeMainToInterfaceTwoPrint = checkInEdges(cg, interfaceTwoPrint, target);
	  boolean edgeMainToInterfaceOnePrint = checkInEdges(cg, interfaceOnePrint, target);
	  
	  final ReachableMethods reachableMethods = Scene.v().getReachableMethods();
	  
	  List<SootMethod> targetMethods = new ArrayList<SootMethod>() {{
		  add(interfaceOnePrint);
		  add(interfaceTwoPrint);		  
	  }};
	  
	  Map<SootMethod, SootMethod> resolvedMethods = new HashMap<SootMethod, SootMethod>() {{
		  put(interfaceTwoPrint, interfaceOneResolvedMethod);
		  put(interfaceTwoPrint, interfaceTwoResolvedMethod);		  		  
	  }};
	  
	  Map<SootMethod, SootMethod> concreteImplTrue = new HashMap<SootMethod, SootMethod>() {{
		  put(interfaceTwoPrint, concreteImplInterfaceOne);
		  put(interfaceTwoPrint, concreteImplInterfaceTwo);		  		  
	  }};
	  
	  Map<SootMethod, SootMethod> concreteImplNotTrue = new HashMap<SootMethod, SootMethod>() {{
		  put(interfaceOnePrint, concreteImplInterfaceOne);
		  put(interfaceOnePrint, concreteImplInterfaceTwo);		  		  
	  }};
	  
	  assertDerivedInterface(targetMethods, resolvedMethods, refMainMethod, reachableMethods, edgeMainToInterfaceTwoPrint, edgeMainToInterfaceOnePrint, concreteImplTrue, concreteImplNotTrue, abstractImplInterfaceOne, abstractImplInterfaceTwo);
=======
    String testClass = "soot.defaultInterfaceMethods.SuperClassInterfaceSameSignature";
    String defaultClass = "soot.defaultInterfaceMethods.PrintInterface";
    String defaultSuperClass = "soot.defaultInterfaceMethods.DefaultPrint";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.PrintInterface",
            "soot.defaultInterfaceMethods.SuperClassImplementsInterface");

    SootMethod defaultSuperMainMethod =
        Scene.v()
            .getMethod("<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void main()>");
    SootMethod mainMethod =
        Scene.v()
            .getMethod(
                "<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>");
    SootMethod defaultMethod =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.PrintInterface: void print()>");
    SootMethod defaultSuperClassMethod =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.DefaultPrint: void print()>");

    Body mainBody = target.retrieveActiveBody();
    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");

    SootMethod resolvedMethod =
        VirtualCalls.v().resolveNonSpecial(Scene.v().getRefType(testClass), defaultMethod, false);
    SootMethod resolvedSuperClassDefaultMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClass), defaultSuperClassMethod, false);

    SootMethod concreteImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), defaultMethod);

    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), defaultMethod);
    Set<SootMethod> abstractImplSuperClass =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(
                Scene.v().getSootClass(defaultSuperClass), defaultSuperClassMethod);

    boolean edgeMainToSuperClassPrint = checkInEdges(mainMethod, target);
    boolean edgeMainToDefaultPrint = checkInEdges(defaultMethod, target);
    boolean edgeMainToSuperDefaultPrint = checkInEdges(defaultSuperClassMethod, target);
    boolean edgeSuperMainToSuperPrint =
        checkInEdges(defaultSuperClassMethod, defaultSuperMainMethod);

    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    List<SootMethod> targetMethods =
        new ArrayList<SootMethod>() {
          {
            add(mainMethod);
            add(defaultMethod);
            add(defaultSuperClassMethod);
          }
        };

    ArrayList<Boolean> edgeNotPresent =
        new ArrayList<Boolean>() {
          {
            add(edgeMainToDefaultPrint);
            add(edgeMainToSuperDefaultPrint);
            add(edgeSuperMainToSuperPrint);
          }
        };

    Map<SootMethod, SootMethod> resolvedMethods =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(mainMethod, resolvedMethod);
            put(resolvedSuperClassDefaultMethod, resolvedMethod);
          }
        };

    for (SootMethod targetMethod : targetMethods) {
      assertNotNull(targetMethod);
    }
    assertEquals(targetMethods.get(0), refMainMethod);
    assertEquals(targetMethods.get(0).getName(), "print");
    assertTrue(edgeMainToSuperClassPrint);
    for (boolean notPresent : edgeNotPresent) {
      assertFalse(notPresent);
    }
    assertEquals(targetMethods.get(0), concreteImpl);
    assertNotEquals(targetMethods.get(1), concreteImpl);
    assertTrue(
        abstractImpl.contains(
            Scene.v()
                .getMethod(
                    "<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>")));
    assertTrue(
        abstractImplSuperClass.contains(
            Scene.v()
                .getMethod(
                    "<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>")));
  }

  @Test
  public void derivedInterfacesTest() {
    String testClassSig = "soot.defaultInterfaceMethods.DerivedInterfaces";
    String defaultInterfaceOneSig = "soot.defaultInterfaceMethods.InterfaceTestOne";
    String defaultInterfaceTwoSig = "soot.defaultInterfaceMethods.InterfaceTestTwo";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClassSig, "void", "main"),
            testClassSig,
            "soot.defaultInterfaceMethods.InterfaceTestOne",
            "soot.defaultInterfaceMethods.InterfaceTestTwo");

    FastHierarchy fh = Scene.v().getFastHierarchy();
    SootClass testClass = Scene.v().getSootClass(testClassSig);
    SootClass defaultInterfaceOne = Scene.v().getSootClass(defaultInterfaceOneSig);
    SootClass defaultInterfaceTwo = Scene.v().getSootClass(defaultInterfaceTwoSig);

    SootMethod interfaceOnePrint =
        Scene.v().getMethod(methodSigFromComponents(defaultInterfaceOneSig, "void print()"));
    SootMethod interfaceTwoPrint =
        Scene.v().getMethod(methodSigFromComponents(defaultInterfaceTwoSig, "void print()"));

    SootMethod refMainMethod =
        resolveMethodRefInBody(target.retrieveActiveBody().getUnits(), "void print()");

    SootMethod interfaceOneResolvedMethod =
        VirtualCalls.v().resolveNonSpecial(testClass.getType(), interfaceOnePrint, false);
    SootMethod interfaceTwoResolvedMethod =
        VirtualCalls.v().resolveNonSpecial(testClass.getType(), interfaceTwoPrint, false);

    SootMethod concreteImplInterfaceOne = fh.resolveConcreteDispatch(testClass, interfaceOnePrint);
    SootMethod concreteImplInterfaceTwo = fh.resolveConcreteDispatch(testClass, interfaceTwoPrint);

    Set<SootMethod> abstractImplInterfaceOne =
        fh.resolveAbstractDispatch(defaultInterfaceOne, interfaceOnePrint);

    boolean edgeMainToInterfaceTwoPrint = checkInEdges(interfaceTwoPrint, target);
    boolean edgeMainToInterfaceOnePrint = checkInEdges(interfaceOnePrint, target);

    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    List<SootMethod> targetMethods =
        new ArrayList<SootMethod>() {
          {
            add(interfaceOnePrint);
            add(interfaceTwoPrint);
          }
        };

    Map<SootMethod, SootMethod> resolvedMethods =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(interfaceTwoPrint, interfaceOneResolvedMethod);
            put(interfaceTwoPrint, interfaceTwoResolvedMethod);
          }
        };

    Map<SootMethod, SootMethod> concreteImplTrue =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(interfaceTwoPrint, concreteImplInterfaceOne);
            put(interfaceTwoPrint, concreteImplInterfaceTwo);
          }
        };

    Map<SootMethod, SootMethod> concreteImplNotTrue =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(interfaceOnePrint, concreteImplInterfaceOne);
            put(interfaceOnePrint, concreteImplInterfaceTwo);
          }
        };

    for (SootMethod targetMethod : targetMethods) {
      Assert.assertNotNull(targetMethod);
    }
    assertEquals(targetMethods.get(1), refMainMethod);
    assertEquals(targetMethods.get(1).getName(), "print");
    assertFalse(edgeMainToInterfaceOnePrint);
    assertTrue(edgeMainToInterfaceTwoPrint);
    assertTrue(reachableMethods.contains(targetMethods.get(1)));
    assertFalse(reachableMethods.contains(targetMethods.get(0)));
    for (Map.Entry<SootMethod, SootMethod> virtualResolvedMethod : resolvedMethods.entrySet()) {
      assertEquals(virtualResolvedMethod.getKey(), virtualResolvedMethod.getValue());
    }
    for (Map.Entry<SootMethod, SootMethod> concreteImpl : concreteImplTrue.entrySet()) {
      assertEquals(concreteImpl.getKey(), concreteImpl.getValue());
    }
    for (Map.Entry<SootMethod, SootMethod> concreteImpl : concreteImplNotTrue.entrySet()) {
      assertNotEquals(concreteImpl.getKey(), concreteImpl.getValue());
    }
    assertEquals(Sets.newHashSet(targetMethods.get(1)), abstractImplInterfaceOne);

    assertEquals(
        Sets.newHashSet(targetMethods.get(1)),
        fh.resolveAbstractDispatch(defaultInterfaceTwo, interfaceTwoPrint));
>>>>>>> Merge and apply some fixes to Pavan's test suite
  }

  @Test
  public void interfaceInheritanceTest() {
    String testClass = "soot.defaultInterfaceMethods.InterfaceInheritance";
    String defaultClass = "soot.defaultInterfaceMethods.InterfaceTestA";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.InterfaceTestA",
            "soot.defaultInterfaceMethods.InterfaceTestB");

    SootMethod interfaceTestAPrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTestA: void print()>");
    SootMethod mainPrintMessageMethod =
        Scene.v()
            .getMethod("<soot.defaultInterfaceMethods.InterfaceInheritance: void printMessage()>");
    Body mainBody = target.retrieveActiveBody();
    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");
    SootMethod resolvedMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClass), interfaceTestAPrint, false);
    SootMethod concreteImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceTestAPrint);
    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), interfaceTestAPrint);

    boolean edgeMainToInterfaceTestAPrint = checkInEdges(interfaceTestAPrint, target);
    boolean edgeMainToMainPrintMessage = checkInEdges(mainPrintMessageMethod, target);
    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    List<SootMethod> targetMethods =
        new ArrayList<SootMethod>() {
          {
            add(interfaceTestAPrint);
            add(mainPrintMessageMethod);
          }
        };

    for (SootMethod targetMethod : targetMethods) {
      Assert.assertNotNull(targetMethod);
    }
    assertEquals(targetMethods.get(0), refMainMethod);
    assertEquals(targetMethods.get(0).getName(), "print");
    assertTrue(edgeMainToInterfaceTestAPrint);
    assertFalse(edgeMainToMainPrintMessage);
    assertTrue(reachableMethods.contains(targetMethods.get(0)));
    assertFalse(reachableMethods.contains(targetMethods.get(1)));
    assertEquals(targetMethods.get(0), resolvedMethod);
    assertEquals(targetMethods.get(0), concreteImpl);
    assertTrue(abstractImpl.contains(targetMethods.get(0)));
  }

  @Test
  public void interfaceReAbstractionTest() {
    String testClass = "soot.defaultInterfaceMethods.InterfaceReAbstracting";
    String defaultClass = "soot.defaultInterfaceMethods.InterfaceA";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.InterfaceA",
            "soot.defaultInterfaceMethods.InterfaceB");

    SootMethod interfaceAPrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceA: void print()>");
    SootMethod mainMethodPrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceReAbstracting: void print()>");

    Body mainBody = target.retrieveActiveBody();
    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");
    SootMethod resolvedMethod =
        VirtualCalls.v().resolveNonSpecial(Scene.v().getRefType(testClass), interfaceAPrint, false);
    SootMethod concreteImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceAPrint);
    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(Scene.v().getSootClass(defaultClass), interfaceAPrint);

    boolean edgeMainMethodToMainPrint = checkInEdges(mainMethodPrint, target);
    boolean edgeMainMethodToInterfaceAPrint = checkInEdges(interfaceAPrint, target);
    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    List<SootMethod> targetMethods =
        new ArrayList<SootMethod>() {
          {
            add(mainMethodPrint);
            add(interfaceAPrint);
          }
        };

    for (SootMethod targetMethod : targetMethods) {
      Assert.assertNotNull(targetMethod);
    }
    assertEquals(targetMethods.get(0), refMainMethod);
    assertEquals(targetMethods.get(0).getName(), "print");
    assertTrue(edgeMainMethodToMainPrint);
    assertFalse(edgeMainMethodToInterfaceAPrint);
    assertTrue(reachableMethods.contains(targetMethods.get(0)));
    assertFalse(reachableMethods.contains(targetMethods.get(1)));
    assertEquals(targetMethods.get(0), resolvedMethod);
    assertEquals(targetMethods.get(0), concreteImpl);
    assertNotEquals(targetMethods.get(1), concreteImpl);
    assertEquals(
        Sets.newHashSet(
            Scene.v()
                .getMethod("<soot.defaultInterfaceMethods.InterfaceReAbstracting: void print()>")),
        abstractImpl);
  }

  @Test
  public void superClassPreferenceOverDefaultMethodTest() {
<<<<<<< HEAD
	  String testClass = "soot.defaultInterfaceMethods.SuperClassPreferenceOverDefaultMethod";
	  String defaultInterfaceOne = "soot.defaultInterfaceMethods.InterfaceOne";
	  String defaultInterfaceTwo = "soot.defaultInterfaceMethods.InterfaceTwo";
	  
	  final SootMethod target =
			  prepareTarget(
					  methodSigFromComponents(testClass, "void", "main"),
					  testClass,
					  "soot.defaultInterfaceMethods.InterfaceOne", "soot.defaultInterfaceMethods.InterfaceTwo", "soot.defaultInterfaceMethods.SuperClass");
	  
	  SootMethod interfaceOnePrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceOne: void print()>");
	  SootMethod interfaceTwoPrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTwo: void print()>");
	  SootMethod superClassPrint = Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClass: void print()>");
	  
	  Body mainBody = target.retrieveActiveBody();
	  SootMethod refMainMethod = getSootMethodRef(mainBody.getUnits(), "void print()");
	  
	  SootMethod resolvedInterfaceOneDefaultMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), interfaceOnePrint, false);
	  SootMethod resolvedInterfaceTwoDefaultMethod = G.v().soot_jimple_toolkits_callgraph_VirtualCalls().resolveNonSpecial(Scene.v().getRefType(testClass), interfaceTwoPrint, false);
	  
	  SootMethod concreteImplInterfaceOne = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceOnePrint);
	  SootMethod concreteImplInterfaceTwo = Scene.v().getFastHierarchy().resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceTwoPrint);
	  
	  Set<SootMethod> abstractImplInterfaceOne = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultInterfaceOne), interfaceOnePrint);
	  Set<SootMethod> abstractImplInterfaceTwo = Scene.v().getFastHierarchy().resolveAbstractDispatch(Scene.v().getSootClass(defaultInterfaceTwo), interfaceTwoPrint);
	  
	  final CallGraph cg = Scene.v().getCallGraph();
	  
	  boolean edgeMainToInterfaceOnePrint = checkInEdges(cg, interfaceOnePrint, target);
	  boolean edgeMainToInterfaceTwoPrint = checkInEdges(cg, interfaceTwoPrint, target);
	  boolean edgeMainToSuperClassPrint = checkInEdges(cg, superClassPrint, target);
	  
	  final ReachableMethods reachableMethods = Scene.v().getReachableMethods();
	  
	  List<SootMethod> targetMethods = new ArrayList<SootMethod>() {{
		  add(superClassPrint);
		  add(interfaceOnePrint);	
		  add(interfaceTwoPrint);	
	  }};
	  
	  ArrayList<Boolean> edgeNotPresent = new ArrayList<Boolean>() {{
		  add(edgeMainToInterfaceOnePrint);
		  add(edgeMainToInterfaceTwoPrint);		  
	  }};
	  
	  Map<SootMethod, SootMethod> resolvedMethods = new HashMap<SootMethod, SootMethod>() {{
		  put(superClassPrint, resolvedInterfaceOneDefaultMethod);
		  put(superClassPrint, resolvedInterfaceTwoDefaultMethod);		  		  
	  }};
	  
	  Map<SootMethod, SootMethod> concreteImplTrue = new HashMap<SootMethod, SootMethod>() {{
		  put(superClassPrint, concreteImplInterfaceOne);
		  put(superClassPrint, concreteImplInterfaceTwo);		  		  
	  }};
	  
	  Map<SootMethod, SootMethod> concreteImplNotTrue = new HashMap<SootMethod, SootMethod>() {{
		  put(interfaceOnePrint, concreteImplInterfaceOne);
		  put(interfaceOnePrint, concreteImplInterfaceTwo);		  		  
	  }};
	  
	  assertSuperClassPreferenceOverDefaultMethod(targetMethods, refMainMethod, edgeMainToSuperClassPrint, edgeNotPresent, reachableMethods, resolvedMethods, concreteImplTrue, concreteImplNotTrue, abstractImplInterfaceOne, abstractImplInterfaceTwo); 
  }
  
  private boolean checkInEdges(CallGraph callGraph, SootMethod defaultMethod, SootMethod targetMethod) {

	  boolean isPresent = false;
	  Iterator<Edge> inEdges = callGraph.edgesInto(defaultMethod);
	  while(inEdges.hasNext()) {
		  MethodOrMethodContext sourceMethod = inEdges.next().getSrc();
		  if(sourceMethod.equals(targetMethod)) {
			  isPresent = true;
		  }
	  }
	  return isPresent;
  }
  
  private SootMethod getSootMethodRef(UnitPatchingChain units, String targetMethod) {
	  
	  SootMethod method = null;
	  for(Unit unit: units) {
		  if(unit instanceof JInvokeStmt && unit.toString().contains(targetMethod) ) {
			  method = ((JInvokeStmt) unit).getInvokeExpr().getMethodRef().tryResolve();			 
		  }
	  }
	  return method;
  }
  
  private void assertdefaultInterfaceTest(SootMethod defaultTargetMethod, ReachableMethods reachableMethods, SootMethod virtualResolvedMethod, boolean edgePresent, SootMethod methodRef, SootMethod concreteImpl, Set<SootMethod> abstractImpl) {
	  
	  assertEquals(defaultTargetMethod, virtualResolvedMethod);
	  assertEquals(defaultTargetMethod, methodRef);
	  assertEquals(defaultTargetMethod.getName(), "target");
	  assertNotNull(defaultTargetMethod);
	  assertTrue(reachableMethods.contains(defaultTargetMethod));
	  assertTrue(edgePresent);
	  assertEquals(defaultTargetMethod, concreteImpl);
	  assertTrue(abstractImpl.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.SimpleDefaultInterface: void target()>")));	
  }
  
  private void assertInterfaceWithSameSignature(Map<SootMethod, String> targetMethods, ReachableMethods reachableMethods, Map<SootMethod, SootMethod> virtualResolvedMethods, List<Boolean> edgePresent, List<Boolean> edgeNotPresent, Map<SootMethod, SootMethod> methodRefs, Map<SootMethod, SootMethod> concreteImpls, Set<SootMethod> abstractImplDefaultRead, Set<SootMethod>abstractImplDefaultWrite, Set<SootMethod> abstractImplReadDefaultPrint, Set<SootMethod>abstractImplWriteDefaultPrint) {
	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertNotNull(targetMethod.getKey());
	  }	  
	  for(Map.Entry<SootMethod, SootMethod> virtualResolvedMethod:virtualResolvedMethods.entrySet()) {
		  assertEquals(virtualResolvedMethod.getKey(), virtualResolvedMethod.getValue());
	  }	  
	  for(Map.Entry<SootMethod, SootMethod> methodRef:methodRefs.entrySet()) {
		  assertEquals(methodRef.getKey(), methodRef.getValue());
	  }	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertEquals(targetMethod.getKey().getName(), targetMethod.getValue());
	  }	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertTrue(reachableMethods.contains(targetMethod.getKey()));
	  }	  
	  for(boolean isPresent:edgePresent) {
		  assertTrue(isPresent);
	  }	  
	  for(boolean notPresent:edgeNotPresent) {
		  assertFalse(notPresent);
	  }	  
	  for(Map.Entry<SootMethod, SootMethod> concreteImpl:concreteImpls.entrySet()) {
		  assertEquals(concreteImpl.getKey(), concreteImpl.getValue());
	  }
	  assertTrue(abstractImplDefaultRead.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void read()>")));
	  assertTrue(abstractImplDefaultWrite.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void write()>")));
	  assertTrue(abstractImplReadDefaultPrint.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void print()>")));
	  assertTrue(abstractImplWriteDefaultPrint.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceSameSignature: void print()>")));
  }
  
  private void assertClassInterfaceWithSameSignature(SootMethod defaultMethod, Map<SootMethod, String> targetMethods, SootMethod virtualResolvedMethod, SootMethod methodRef, ReachableMethods reachableMethods, List<Boolean> edgePresent, SootMethod concreteImpl, Set<SootMethod> abstractImpl) {
	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertNotNull(targetMethod.getKey());
	  }	  
	  assertEquals(defaultMethod, virtualResolvedMethod);
	  assertEquals(defaultMethod, methodRef);	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertEquals(targetMethod.getKey().getName(), targetMethod.getValue());
	  }	  
	  for(Map.Entry<SootMethod, String> targetMethod:targetMethods.entrySet()) {
		  assertTrue(reachableMethods.contains(targetMethod.getKey()));
	  }	  
	  for(boolean isPresent:edgePresent) {
		  assertTrue(isPresent);
	  }	  
	  assertEquals(defaultMethod, concreteImpl);
	  assertTrue(abstractImpl.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.ClassInterfaceSameSignature: void print()>")));
  }
  
  private void assertSuperClassInterfaceWithSameSignature(List<SootMethod> targetMethods, Map<SootMethod, SootMethod> virtualResolvedMethods, SootMethod methodRef, ReachableMethods reachableMethods, boolean edgePresent, List<Boolean> edgeNotPresent, SootMethod concreteImpl, Set<SootMethod> abstractImpl, Set<SootMethod> abstractImplSuperClass) {
	  for(SootMethod targetMethod: targetMethods) {
		  assertNotNull(targetMethod);
	  }	  
	  assertEquals(targetMethods.get(0), methodRef);
	  assertEquals(targetMethods.get(0).getName(), "print");
	  assertTrue(edgePresent);	  
	  for(boolean notPresent:edgeNotPresent) {
		  assertFalse(notPresent);
	  }
	  assertEquals(targetMethods.get(0), concreteImpl);	  
	  assertNotEquals(targetMethods.get(1), concreteImpl); 
	  assertTrue(abstractImpl.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>")));
	  assertTrue(abstractImplSuperClass.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClassImplementsInterface: void print()>")));
	  
  }
  
  private void assertDerivedInterface(List<SootMethod> targetMethods, Map<SootMethod, SootMethod> virtualResolvedMethods, SootMethod methodRef, ReachableMethods reachableMethods, boolean edgePresent, boolean edgeNotPresent, Map<SootMethod, SootMethod> concreteImplsTrue, Map<SootMethod, SootMethod> concreteImplsNotTrue, Set<SootMethod> abstractImplInterfaceOne, Set<SootMethod> abstractImplInterfaceTwo) {
	  
	  for(SootMethod targetMethod: targetMethods) {
		  Assert.assertNotNull(targetMethod);
	  }	  
	  assertEquals(targetMethods.get(0), methodRef);
	  assertEquals(targetMethods.get(1).getName(), "print"); 	  
	  assertFalse(edgeNotPresent);
	  assertTrue(edgePresent);
	  assertTrue(reachableMethods.contains(targetMethods.get(1)));
	  assertFalse(reachableMethods.contains(targetMethods.get(0)));
	  for(Map.Entry<SootMethod, SootMethod> virtualResolvedMethod:virtualResolvedMethods.entrySet()) {
		  assertEquals(virtualResolvedMethod.getKey(), virtualResolvedMethod.getValue());
	  }
	  for(Map.Entry<SootMethod, SootMethod> concreteImpl:concreteImplsTrue.entrySet()) {
		  assertEquals(concreteImpl.getKey(), concreteImpl.getValue());
	  }
	  for(Map.Entry<SootMethod, SootMethod> concreteImpl:concreteImplsNotTrue.entrySet()) {
		  assertNotEquals(concreteImpl.getKey(), concreteImpl.getValue());
	  } 
	  assertTrue(abstractImplInterfaceOne.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.DerivedInterfaces: void print()>")));
	  assertTrue(abstractImplInterfaceOne.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTestTwo: void print()>")));
	  assertTrue(abstractImplInterfaceTwo.contains(Scene.v().getMethod("<soot.defaultInterfaceMethods.DerivedInterfaces: void print()>")));
=======
    String testClass = "soot.defaultInterfaceMethods.SuperClassPreferenceOverDefaultMethod";
    String defaultInterfaceOne = "soot.defaultInterfaceMethods.InterfaceOne";
    String defaultInterfaceTwo = "soot.defaultInterfaceMethods.InterfaceTwo";

    final SootMethod target =
        prepareTarget(
            methodSigFromComponents(testClass, "void", "main"),
            testClass,
            "soot.defaultInterfaceMethods.InterfaceOne",
            "soot.defaultInterfaceMethods.InterfaceTwo",
            "soot.defaultInterfaceMethods.SuperClass");

    SootMethod interfaceOnePrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceOne: void print()>");
    SootMethod interfaceTwoPrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.InterfaceTwo: void print()>");
    SootMethod superClassPrint =
        Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClass: void print()>");

    Body mainBody = target.retrieveActiveBody();
    SootMethod refMainMethod = resolveMethodRefInBody(mainBody.getUnits(), "void print()");

    SootMethod resolvedInterfaceOneDefaultMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClass), interfaceOnePrint, false);
    SootMethod resolvedInterfaceTwoDefaultMethod =
        VirtualCalls.v()
            .resolveNonSpecial(Scene.v().getRefType(testClass), interfaceTwoPrint, false);

    SootMethod concreteImplInterfaceOne =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceOnePrint);
    SootMethod concreteImplInterfaceTwo =
        Scene.v()
            .getFastHierarchy()
            .resolveConcreteDispatch(Scene.v().getSootClass(testClass), interfaceTwoPrint);

    Set<SootMethod> abstractImplInterfaceOne =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(
                Scene.v().getSootClass(defaultInterfaceOne), interfaceOnePrint);
    Set<SootMethod> abstractImplInterfaceTwo =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(
                Scene.v().getSootClass(defaultInterfaceTwo), interfaceTwoPrint);

    boolean edgeMainToInterfaceOnePrint = checkInEdges(interfaceOnePrint, target);
    boolean edgeMainToInterfaceTwoPrint = checkInEdges(interfaceTwoPrint, target);
    boolean edgeMainToSuperClassPrint = checkInEdges(superClassPrint, target);

    final ReachableMethods reachableMethods = Scene.v().getReachableMethods();

    List<SootMethod> targetMethods =
        new ArrayList<SootMethod>() {
          {
            add(superClassPrint);
            add(interfaceOnePrint);
            add(interfaceTwoPrint);
          }
        };

    ArrayList<Boolean> edgeNotPresent =
        new ArrayList<Boolean>() {
          {
            add(edgeMainToInterfaceOnePrint);
            add(edgeMainToInterfaceTwoPrint);
          }
        };

    Map<SootMethod, SootMethod> resolvedMethods =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(superClassPrint, resolvedInterfaceOneDefaultMethod);
            put(superClassPrint, resolvedInterfaceTwoDefaultMethod);
          }
        };

    Map<SootMethod, SootMethod> concreteImplTrue =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(superClassPrint, concreteImplInterfaceOne);
            put(superClassPrint, concreteImplInterfaceTwo);
          }
        };

    Map<SootMethod, SootMethod> concreteImplNotTrue =
        new HashMap<SootMethod, SootMethod>() {
          {
            put(interfaceOnePrint, concreteImplInterfaceOne);
            put(interfaceOnePrint, concreteImplInterfaceTwo);
          }
        };

    for (SootMethod targetMethod : targetMethods) {
      assertNotNull(targetMethod);
    }
    assertEquals(targetMethods.get(0), refMainMethod);
    assertEquals(targetMethods.get(0).getName(), "print");
    assertTrue(edgeMainToSuperClassPrint);
    for (boolean notPresent : edgeNotPresent) {
      assertFalse(notPresent);
    }
    assertTrue(reachableMethods.contains(targetMethods.get(0)));
    assertFalse(reachableMethods.contains(targetMethods.get(1)));
    assertFalse(reachableMethods.contains(targetMethods.get(2)));
    for (Map.Entry<SootMethod, SootMethod> virtualResolvedMethod : resolvedMethods.entrySet()) {
      assertEquals(virtualResolvedMethod.getKey(), virtualResolvedMethod.getValue());
    }
    for (Map.Entry<SootMethod, SootMethod> concreteImpl : concreteImplTrue.entrySet()) {
      assertEquals(concreteImpl.getKey(), concreteImpl.getValue());
    }
    for (Map.Entry<SootMethod, SootMethod> concreteImpl : concreteImplNotTrue.entrySet()) {
      assertNotEquals(concreteImpl.getKey(), concreteImpl.getValue());
    }
    assertTrue(
        abstractImplInterfaceOne.contains(
            Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClass: void print()>")));
    assertTrue(
        abstractImplInterfaceTwo.contains(
            Scene.v().getMethod("<soot.defaultInterfaceMethods.SuperClass: void print()>")));
>>>>>>> Merge and apply some fixes to Pavan's test suite
  }

  private boolean checkInEdges(SootMethod defaultMethod, SootMethod targetMethod) {

    boolean isPresent = false;
    Iterator<Edge> inEdges = Scene.v().getCallGraph().edgesInto(defaultMethod);
    while (inEdges.hasNext()) {
      MethodOrMethodContext sourceMethod = inEdges.next().getSrc();
      if (sourceMethod.equals(targetMethod)) {
        isPresent = true;
      }
    }
    return isPresent;
  }

  /**
   * Searches the given unit chain for the first call to a method with the given subsignature and
   * resolves it's MethodRef
   *
   * @param units
   * @param methodSubSig
   * @return
   */
  private SootMethod resolveMethodRefInBody(UnitPatchingChain units, String methodSubSig) {

    SootMethod method = null;
    for (Unit unit : units) {
      Stmt s = (Stmt) unit;
      if (s.containsInvokeExpr()
          && s.getInvokeExpr().getMethodRef().getSignature().contains(methodSubSig)) {
        return s.getInvokeExpr().getMethodRef().tryResolve();
      }
    }
    return null;
  }

  @Test
  public void maximallySpecificSuperInterface() {
    String targetClassName = "soot.defaultInterfaceMethods.MaximallySpecificSuperInterface";
    String superClass = "soot.defaultInterfaceMethods.B";
    String subInterface = "soot.defaultInterfaceMethods.C";
    String superInterface = "soot.defaultInterfaceMethods.D";

    final SootMethod mainMethod =
        prepareTarget(
            methodSigFromComponents(targetClassName, "void", "main"),
            targetClassName,
            superClass,
            subInterface,
            superInterface);

    SootClass testClass = mainMethod.getDeclaringClass();

    SootMethod subInterfacePrint =
        Scene.v().getMethod(methodSigFromComponents(subInterface, "void print()"));
    SootMethod superInterfacePrint =
        Scene.v().getMethod(methodSigFromComponents(superInterface, "void print()"));

    SootMethod methodRefResolved =
        resolveMethodRefInBody(mainMethod.retrieveActiveBody().getUnits(), "void print()");
    assertEquals(subInterfacePrint, methodRefResolved);

    SootMethod virtualCallsResolved =
        VirtualCalls.v().resolveNonSpecial(testClass.getType(), superInterfacePrint, false);
    assertEquals(subInterfacePrint, virtualCallsResolved);

    SootMethod concreteImplI1 =
        Scene.v().getFastHierarchy().resolveConcreteDispatch(testClass, superInterfacePrint);
    assertEquals(subInterfacePrint, concreteImplI1);

    Set<SootMethod> abstractImpl =
        Scene.v()
            .getFastHierarchy()
            .resolveAbstractDispatch(superInterfacePrint.getDeclaringClass(), superInterfacePrint);
    assertEquals(Sets.newHashSet(subInterfacePrint), abstractImpl);

    assertTrue(checkInEdges(subInterfacePrint, mainMethod));
    assertTrue(Scene.v().getReachableMethods().contains(subInterfacePrint));
  }
}
